ttest <- subset(train,sampsplit=FALSE)
rm(train,test)
rmsle <- function(ref,pred){
n <- length(ref)
result <- sqrt(1/n*sum((log(ref+1)-log(pred+1))^2))
result
}
require(randomForest)
require(rpart)
require(caretEnsemble)
require(caret)
my_control <- trainControl(
method='oob',
number=25,
verboseIter=TRUE,
savePredictions=TRUE,
index=createResample(ttrain$Cost, 25),
summaryFunction=defaultSummary
)
model_list <- caretList(
log(ttrain$cost+1)~., data=ttrain,
trControl=my_control,
tuneList=list(
rf1=caretModelSpec(method='rf', tuneGrid=data.frame(.mtry=2,.ntree=20,.nodesize=5,.do.trace = 2)),
rf2=caretModelSpec(method='rf', tuneGrid=data.frame(.mtry=10,.ntree=20,.nodesize=5,.do.trace = 2),preProcess='pca'),
rf3=caretModelSpec(method='rf', tuneGrid=data.frame(.mtry=20,.ntree=20,.nodesize=5,.do.trace = 2),preProcess='pca'),
nn=caretModelSpec(method='nnet', tuneLength=2, trace=FALSE)
)
)
greedy_ensemble <- caretEnsemble(model_list)
train <- read.csv("~/Kaggle/Tubes/output/train.csv")
test <- read.csv("~/Kaggle/Tubes/output/test.csv")
set.seed(1000)
require(caTools)
sampsplit <- sample.split(train$cost,0.7)
ttrain <- subset(train,sampsplit=TRUE)
ttest <- subset(train,sampsplit=FALSE)
ttrain <- ttrain[,-match(c("end_form_id", "forming","spec10"), names(ttrain))]
ttest <- ttest[,-match(c("end_form_id", "forming","spec10"), names(ttest))]
rm(train,test)
rmsle <- function(ref,pred){
n <- length(ref)
result <- sqrt(1/n*sum((log(ref+1)-log(pred+1))^2))
result
}
require(rpart)
require(caretEnsemble)
require(caret)
require(randomForest)
my_control <- trainControl(
method='oob',
number=25,
verboseIter=TRUE,
savePredictions=TRUE,
index=createResample(ttrain$Cost, 25),
summaryFunction=defaultSummary
)
model_list <- caretList(
log(ttrain$cost+1)~., data=ttrain,
trControl=my_control,
tuneList=list(
rf1=caretModelSpec(method='rf', tuneGrid=data.frame(.mtry=2),preProcess='pca')
#rf2=caretModelSpec(method='rf', tuneGrid=data.frame(.mtry=4),preProcess='pca'),
#rf3=caretModelSpec(method='rf', tuneGrid=data.frame(.mtry=6),preProcess='pca')
#nn=caretModelSpec(method='nnet', tuneLength=2, trace=FALSE)
)
)
greedy_ensemble <- caretEnsemble(model_list)
ttrain <- preProcess(ttrain,method="pca")
require(rpart)
require(caretEnsemble)
require(caret)
require(randomForest)
my_control <- trainControl(
method='oob',
number=25,
verboseIter=TRUE,
savePredictions=TRUE,
index=createResample(ttrain$Cost, 25),
summaryFunction=defaultSummary
)
model_list <- caretList(
log(ttrain$cost+1)~., data=ttrain,
trControl=my_control,
tuneList=list(
#rf1=caretModelSpec(method='rf', tuneGrid=data.frame(.mtry=2),preProcess='pca')
#rf2=caretModelSpec(method='rf', tuneGrid=data.frame(.mtry=4),preProcess='pca'),
#rf3=caretModelSpec(method='rf', tuneGrid=data.frame(.mtry=6),preProcess='pca')
nn=caretModelSpec(method='nnet', tuneLength=2, trace=TRUE)
)
)
my_control <- trainControl(
method='boot',
number=25,
verboseIter=TRUE,
savePredictions=TRUE,
index=createResample(ttrain$Cost, 25),
summaryFunction=defaultSummary
)
model_list <- caretList(
log(ttrain$cost+1)~., data=ttrain,
trControl=my_control,
tuneList=list(
#rf1=caretModelSpec(method='rf', tuneGrid=data.frame(.mtry=2),preProcess='pca')
#rf2=caretModelSpec(method='rf', tuneGrid=data.frame(.mtry=4),preProcess='pca'),
#rf3=caretModelSpec(method='rf', tuneGrid=data.frame(.mtry=6),preProcess='pca')
nn=caretModelSpec(method='nnet', tuneLength=2, trace=TRUE)
)
)
greedy_ensemble <- caretEnsemble(model_list)
model_list <- caretList(
log(ttrain$cost+1)~., data=ttrain,
methodList=c('glm', 'rpart')
)
glm_ensemble <- caretStack(
model_list,
method='glm',
metric='ROC',
trControl=trainControl(
method='boot',
number=10,
savePredictions=TRUE,
classProbs=TRUE,
summaryFunction=defaultSummary
)
)
train <- read.csv("~/Kaggle/Tubes/output/train.csv")
test <- read.csv("~/Kaggle/Tubes/output/test.csv")
train <- train[,-match(c("end_form_id", "forming","spec10"), names(train))]
test <- test[,-match(c("end_form_id", "forming","spec10"), names(test))]
install.packages("doMC")
require(doMC)
registerDoMC(4)
require(caret)
rf_model<-train(log(train$cost+1)~.,data=train[,-match(c("id", "cost"), names(train))],method="rf",
ntree=30,nodesize=5,do.trace = 2)
require(caret)
emails <- read.csv("~/Courses/MITEdx/emails.csv")
View(emails)
str(emails)
table(emails$spam)
library(tm)
corpus=Corpus(VectorSource(emails$text))
corpus=tm_map(corpus,tolower)
corpus=tm_map(corpus,PlainTextDocument)
corpus=tm_map(corpus,removePunctuation)
corpus=tm_map(corpus,removeWords,stopwords("english"))
corpus=tm_map(corpus,StemDocument)
corpus=Corpus(VectorSource(emails$text))
corpus=tm_map(corpus,tolower)
corpus=tm_map(corpus,PlainTextDocument)
corpus=tm_map(corpus,removePunctuation)
corpus=tm_map(corpus,removeWords,stopwords("english"))
corpus=tm_map(corpus,stemDocument)
corpus=Corpus(VectorSource(emails$text))
corpus=tm_map(corpus,tolower)
corpus=tm_map(corpus,PlainTextDocument)
corpus=tm_map(corpus,removePunctuation)
corpus=tm_map(corpus,removeWords,stopwords("english"))
corpus = tm_map(corpus, stemDocument)
dtm=DocumentTermMatrix(corpus)
length(stopwords("english"))
corpus=Corpus(VectorSource(emails$text))
corpus=tm_map(corpus,tolower)
corpus=tm_map(corpus,PlainTextDocument)
corpus=tm_map(corpus,removePunctuation)
sW = stopwords("english")
corpus=tm_map(corpus,removeWords,sW)
corpus = tm_map(corpus, stemDocument)
library(tm)
install.packages("igraph")
require(igraph)
directedEdges <- read.csv("~/Projects/PageRank/FlowFormulation/Graph/directedEdges.csv", header=FALSE)
View(directedEdges)
directedEdges.network<-graph.data.frame(directedEdges, directed=F)
plot(directedEdges.network)
directedEdges.network<-graph.data.frame(directedEdges, directed=T)
plot(directedEdges.network)
V(directedEdges.network)
E(directedEdges.network)[from(V(directedEdges.network)[0])]
V(directedEdges.network)[0]
V(directedEdges.network)
V(directedEdges.network)[1]
V(directedEdges.network)[0]
V(directedEdges.network)[2]
V(directedEdges.network)[4]
E(directedEdges.network)[from(V(directedEdges.network)[1])]
E(directedEdges.network)[from(V(directedEdges.network)[1])][1]
E(directedEdges.network)[from(V(directedEdges.network)[1])][1][1]
from(V(directedEdges.network)[1]
from(V(directedEdges.network)[1]))
from(V(directedEdges.network)[1])
V(directedEdges.network)[from(V(directedEdges.network)[1])]
directedEdges <- read.csv("~/Projects/PageRank/FlowFormulation/Graph/directedEdges.csv", header=FALSE)
View(directedEdges)
require(igraph)
#In this Flow Formulation, Self Loops,Spider Traps and Dead Ends in Graph are not supported
#load directed edges from the file
directedEdges <- read.csv("../Graph/directedEdges.csv", header=FALSE)
directedEdges.network<-graph.data.frame(directedEdges, directed=T)
#Calculate number of vertices from the graph
noofvertices <- length(V(directedEdges.network)$name)
#Initialize coefficient matrix with zeroes
coefficientMatrix <- matrix(0,noofvertices,noofvertices)
#Creating Coefficient matrix from the data
i = 1
for (node in V(directedEdges.network)$name) {
coefficientMatrix[i,i] <- 1.0
for (vertex in V(directedEdges.network)[nei(node,"in")]){
coefficientMatrix[i,match(vertex,V(directedEdges.network)$name)] = -1.0/as.integer(degree(directedEdges.network,vertex,mode=c("out")))
}
i = i+1
}
#Additonal Constraint that all page ranks sum to 1
additionalConstraint = rep(1,noofvertices)
#adding bias
bias = rep(1,noofvertices+1)
#Dependent variable in each equation
Y = c(rep(0,noofvertices),1)
colnames(coefficientMatrix) = V(directedEdges.network)$name
coefficientMatrixWithConstraint = rbind(coefficientMatrix,additionalConstraint)
finalcoefficientMatrix = cbind(coefficientMatrixWithConstraint,bias)
rm(coefficientMatrixWithConstraint,additionalConstraint,bias,i,node,vertex,coefficientMatrix,directedEdges)
#Using linear regression model
model <- lm(Y ~ finalcoefficientMatrix)
#Printing Vertices First
print(V(directedEdges.network)$name)
#Printing PageRanks of above vertices
print(summary(model)$coefficients[c(2:noofvertices+1)])
print(summary(model)$coefficients[c(1:noofvertices)])
print(summary(model)$coefficients[c(1:noofvertices+1)])
print(summary(model)$coefficients[c(1:noofvertices)])
print(summary(model)$coefficients[c(2:noofvertices)])
print(summary(model)$coefficients[c(2:noofvertices+1)])
print(summary(model)$coefficients[c(1:noofvertices+1)])
print(summary(model)$coefficients
)
print(summary(model)$coefficients[1:5])
print(summary(model)$coefficients[1:5])
print(summary(model)$coefficients[1:5])
print(summary(model)$coefficients[2:6])
print(summary(model)$coefficients[2:7])
print(summary(model)$coefficients[2:noofvertices+1])
print(summary(model)$coefficients[1:noofvertices+1])
model <- lm(Y ~ finalcoefficientMatrix)
#Printing Vertices First
print(V(directedEdges.network)$name)
#Printing PageRanks of above vertices
print(summary(model)$coefficients[1:noofvertices+1])
directedEdges <- read.csv("~/Projects/PageRank/FlowFormulation/Graph/directedEdges.csv", header=FALSE)
View(directedEdges)
require(igraph)
directedEdges.network<-graph.data.frame(directedEdges, directed=T)
#Calculate number of vertices from the graph
noofvertices <- length(V(directedEdges.network)$name)
#Initialize coefficient matrix with zeroes
coefficientMatrix <- matrix(0,noofvertices,noofvertices)
#Creating Coefficient matrix from the data
i = 1
for (node in V(directedEdges.network)$name) {
coefficientMatrix[i,i] <- 1.0
for (vertex in V(directedEdges.network)[nei(node,"in")]){
coefficientMatrix[i,match(vertex,V(directedEdges.network)$name)] = -1.0/as.integer(degree(directedEdges.network,vertex,mode=c("out")))
}
i = i+1
}
#Additonal Constraint that all page ranks sum to 1
additionalConstraint = rep(1,noofvertices)
#adding bias
bias = rep(1,noofvertices+1)
#Dependent variable in each equation
Y = c(rep(0,noofvertices),1)
colnames(coefficientMatrix) = V(directedEdges.network)$name
coefficientMatrixWithConstraint = rbind(coefficientMatrix,additionalConstraint)
finalcoefficientMatrix = cbind(coefficientMatrixWithConstraint,bias)
rm(coefficientMatrixWithConstraint,additionalConstraint,bias,i,node,vertex,coefficientMatrix,directedEdges)
#Using linear regression model
model <- lm(Y ~ finalcoefficientMatrix)
#Printing Vertices First
print(V(directedEdges.network)$name)
#Printing PageRanks of above vertices
print(summary(model)$coefficients[1:noofvertices+1])
print(summary(model)$coefficients[2:noofvertices+1])
print(summary(model)$coefficients[1:noofvertices+1])
print(summary(model)$coefficients[1:noofvertices+2])
print(summary(model)$coefficients[1:noofvertices+1])
print(summary(model)$coefficients[0:noofvertices+1])
print(summary(model)$coefficients[1:noofvertices+1])
directedEdges <- read.csv("~/Projects/PageRank/MatrixFormulation/Graph/directedEdges.csv", header=FALSE)
View(directedEdges)
require(igraph)
beta = 0.85
#load directed edges from the file
directedEdges.network<-graph.data.frame(directedEdges, directed=T)
#Calculate number of vertices from the graph
noofvertices <- length(V(directedEdges.network)$name)
#initialize stochastic matrix with zeroes
stochasticMatrix <- matrix(0,noofvertices,noofvertices)
#Creating Coefficient matrix from the data
i = 1
for (node in V(directedEdges.network)$name) {
for (vertex in V(directedEdges.network)[nei(node,"in")]){
stochasticMatrix[i,match(vertex,V(directedEdges.network)$name)] = -1.0/as.integer(degree(directedEdges.network,vertex,mode=c("out")))
}
i = i+1
}
stochasticMatrix = beta*stochasticMatrix + (1-beta)/noofvertices*matrix(1,noofvertices,noofvertices)
#initialize random page ranks for each node
pageRanks = runif(noofvertices)
#sum of pageranks must be one
pageRanks = pageRanks/sum(pageRanks)
stochasticMatrix %*% pageRanks
directedEdges <- read.csv("~/Projects/PageRank/FlowFormulation/Graph/directedEdges.csv", header=FALSE)
View(directedEdges)
require(igraph)
beta = 0.85
#load directed edges from the file
directedEdges.network<-graph.data.frame(directedEdges, directed=T)
#Calculate number of vertices from the graph
noofvertices <- length(V(directedEdges.network)$name)
#initialize stochastic matrix with zeroes
stochasticMatrix <- matrix(0,noofvertices,noofvertices)
#Creating Coefficient matrix from the data
i = 1
for (node in V(directedEdges.network)$name) {
for (vertex in V(directedEdges.network)[nei(node,"in")]){
stochasticMatrix[i,match(vertex,V(directedEdges.network)$name)] = 1.0/as.integer(degree(directedEdges.network,vertex,mode=c("out")))
}
i = i+1
}
#add (1-beta)/numberOfNodes*matrixwithallones for spidertraps, deadends and self-loops
stochasticMatrix = beta*stochasticMatrix + (1-beta)/noofvertices*matrix(1,noofvertices,noofvertices)
#initialize random page ranks for each node
pageRanks = runif(noofvertices)
#sum of pageranks must be one
pageRanks = pageRanks/sum(pageRanks)
stochasticMatrix %*% pageRanks
#initialize stochastic matrix with zeroes
stochasticMatrix <- matrix(0,noofvertices,noofvertices)
#Creating Coefficient matrix from the data
i = 1
for (node in V(directedEdges.network)$name) {
for (vertex in V(directedEdges.network)[nei(node,"in")]){
stochasticMatrix[i,match(vertex,V(directedEdges.network)$name)] = 1.0/as.integer(degree(directedEdges.network,vertex,mode=c("out")))
}
i = i+1
}
#add (1-beta)/numberOfNodes*matrixwithallones for spidertraps, deadends and self-loops
stochasticMatrix = beta*stochasticMatrix + (1-beta)/noofvertices*matrix(1,noofvertices,noofvertices)
#initialize random page ranks for each node
pageRanks = runif(noofvertices)
#sum of pageranks must be one
pageRanks = pageRanks/sum(pageRanks)
#Iterative Calculation for Pageranks
for (i in 1:1000){
tempPageRanks <- stochasticMatrix %*% pageRanks
tempPageRanks = tempPageRanks/sum(tempPageRanks)
if (sum(pageRanks - tempPageRanks) < 0.000001){
break
}else{
pageRanks = tempPageRanks
}
}
require(igraph)
beta = 0.85
directedEdges.network<-graph.data.frame(directedEdges, directed=T)
#Calculate number of vertices from the graph
noofvertices <- length(V(directedEdges.network)$name)
#initialize stochastic matrix with zeroes
stochasticMatrix <- matrix(0,noofvertices,noofvertices)
#Creating Coefficient matrix from the data
i = 1
for (node in V(directedEdges.network)$name) {
for (vertex in V(directedEdges.network)[nei(node,"in")]){
stochasticMatrix[i,match(vertex,V(directedEdges.network)$name)] = 1.0/as.integer(degree(directedEdges.network,vertex,mode=c("out")))
}
i = i+1
}
#add (1-beta)/numberOfNodes*matrixwithallones for spidertraps, deadends and self-loops
stochasticMatrix = beta*stochasticMatrix + (1-beta)/noofvertices*matrix(1,noofvertices,noofvertices)
#initialize random page ranks for each node
pageRanks = runif(noofvertices)
#sum of pageranks must be one
pageRanks = pageRanks/sum(pageRanks)
#Iterative Calculation for Pageranks
for (i in 1:1000){
tempPageRanks <- stochasticMatrix %*% pageRanks
tempPageRanks = tempPageRanks/sum(tempPageRanks)
if (sum(pageRanks - tempPageRanks) < 0.000001){
break
}else{
pageRanks = tempPageRanks
}
}
#Printing Vertices First
print(V(directedEdges.network)$name)
#Printing PageRanks of above vertices
print(pageRanks)
directedEdges <- read.csv("~/Projects/PageRank/FlowFormulation/Graph/directedEdges.csv", header=FALSE)
View(directedEdges)
require(igraph)
#In this Flow Formulation, Self Loops,Spider Traps and Dead Ends in Graph are not supported
#load directed edges from the file
directedEdges.network<-graph.data.frame(directedEdges, directed=T)
#Calculate number of vertices from the graph
noofvertices <- length(V(directedEdges.network)$name)
#Initialize coefficient matrix with zeroes
coefficientMatrix <- matrix(0,noofvertices,noofvertices)
#Creating Coefficient matrix from the data
i = 1
for (node in V(directedEdges.network)$name) {
coefficientMatrix[i,i] <- 1.0
for (vertex in V(directedEdges.network)[nei(node,"in")]){
coefficientMatrix[i,match(vertex,V(directedEdges.network)$name)] = -1.0/as.integer(degree(directedEdges.network,vertex,mode=c("out")))
}
i = i+1
}
#Additonal Constraint that all page ranks sum to 1
additionalConstraint = rep(1,noofvertices)
#adding bias
bias = rep(1,noofvertices+1)
#Dependent variable in each equation
Y = c(rep(0,noofvertices),1)
colnames(coefficientMatrix) = V(directedEdges.network)$name
coefficientMatrixWithConstraint = rbind(coefficientMatrix,additionalConstraint)
finalcoefficientMatrix = cbind(coefficientMatrixWithConstraint,bias)
rm(coefficientMatrixWithConstraint,additionalConstraint,bias,i,node,vertex,coefficientMatrix,directedEdges)
#Using linear regression model
model <- lm(Y ~ finalcoefficientMatrix)
#Printing Vertices First
print(V(directedEdges.network)$name)
#Printing PageRanks of above vertices
print(summary(model)$coefficients[1:noofvertices+1])
directedEdges <- read.csv("~/Projects/PageRank/FlowFormulation/Graph/directedEdges.csv", header=FALSE)
View(directedEdges)
require(igraph)
beta = 0.85
#load directed edges from the file
directedEdges.network<-graph.data.frame(directedEdges, directed=T)
#Calculate number of vertices from the graph
noofvertices <- length(V(directedEdges.network)$name)
#initialize stochastic matrix with zeroes
stochasticMatrix <- matrix(0,noofvertices,noofvertices)
#Creating Coefficient matrix from the data
i = 1
for (node in V(directedEdges.network)$name) {
for (vertex in V(directedEdges.network)[nei(node,"in")]){
stochasticMatrix[i,match(vertex,V(directedEdges.network)$name)] = 1.0/as.integer(degree(directedEdges.network,vertex,mode=c("out")))
}
i = i+1
}
#add (1-beta)/numberOfNodes*matrixwithallones for spidertraps, deadends and self-loops
stochasticMatrix = beta*stochasticMatrix + (1-beta)/noofvertices*matrix(1,noofvertices,noofvertices)
#initialize random page ranks for each node
pageRanks = runif(noofvertices)
#sum of pageranks must be one
pageRanks = pageRanks/sum(pageRanks)
#Iterative Calculation for Pageranks
for (i in 1:1000){
tempPageRanks <- stochasticMatrix %*% pageRanks
tempPageRanks = tempPageRanks/sum(tempPageRanks)
if (sum(abs(pageRanks - tempPageRanks)) < 0.000001){
break
}else{
pageRanks = tempPageRanks
}
}
#Printing Vertices First
print(V(directedEdges.network)$name)
#Printing PageRanks of above vertices
print(pageRanks)
setwd("~/Projects/PageRank/MatrixFormulation/R")
require(igraph)
beta = 0.9
#load directed edges from the file
directedEdges <- read.csv("../Graph/directedEdges.csv", header=FALSE)
#convert above dataframe into graph data frame of igraph
directedEdges.network<-graph.data.frame(directedEdges, directed=T)
#Calculate number of vertices from the graph
noofvertices <- length(V(directedEdges.network)$name)
#initialize stochastic matrix with zeroes
stochasticMatrix <- matrix(0,noofvertices,noofvertices)
#Creating Coefficient matrix from the data
i = 1
for (node in sort(V(directedEdges.network)$name)) {
for (vertex in V(directedEdges.network)[nei(node,"in")]){
stochasticMatrix[i,match(vertex,V(directedEdges.network)$name)] = 1.0/as.integer(degree(directedEdges.network,vertex,mode=c("out")))
}
i = i+1
}
#add (1-beta)/numberOfNodes*matrixwithallones for spidertraps, deadends and self-loops
stochasticMatrix = beta*stochasticMatrix + (1-beta)/noofvertices*matrix(1,noofvertices,noofvertices)
#initialize random page ranks for each node
pageRanks = rep(1.0/noofvertices,noofvertices)
#sum of pageranks must be one
pageRanks = pageRanks/sum(pageRanks)
for (i in 1:1000){
#  print(pageRanks)
tempPageRanks <- stochasticMatrix %*% pageRanks
#  print(tempPageRanks)
rankSum = sum(tempPageRanks)
tempPageRanks = tempPageRanks + (1-rankSum)/noofvertices
if (sum(abs(pageRanks - tempPageRanks)) < 0.000001){
pageRanks = tempPageRanks
break
}else{
pageRanks = tempPageRanks
}
}
print(sort(V(directedEdges.network)$name))
#Printing PageRanks of above vertices
print(pageRanks)
